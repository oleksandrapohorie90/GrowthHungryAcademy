Problem 13 â€” Fibonacci Induction Proof
We prove this using the principle of mathematical induction. The base case is
n=1, and in that case, the statement to be proved is just:
ð‘“1=ð‘“2
This is true since both values are 1.

Inductive Step: Assume the inductive hypothesis:
ð‘“1+ð‘“3+ ... +ð‘“2n-1 = ð‘“2ð‘›
Try to prove the corresponding statement for ð‘›+1 namely:
ð‘“1+ð‘“3+ ... +ð‘“2n-1 +ð‘“2n+1 = +ð‘“2n+2 - by inductive hypothesis
We have:
ð‘“1+ð‘“3+ ... +ð‘“2ð‘›âˆ’1+ð‘“2ð‘›+1=ð‘“2ð‘›+ð‘“2ð‘›+1 = ð‘“2ð‘›+2 - by definition of Fib numbers

Problem 25
a) Since we can generate all even integers by starting with 0 and repeatedly adding or subtracting 2, a simple recursive way to define this set is:
0 âˆˆ ð‘†
If ð‘¥âˆˆð‘† then x+2 âˆˆ ð‘† and ð‘¥âˆ’2 âˆˆ ð‘†

b) The smallest positive integer congruent to 2 modulo 3 is 2, so declare 2âˆˆS. All the others can be obtained by adding multiples of 3. So the inductive step is:
If xâˆˆS, then x+3âˆˆS

c) The positive integers not divisible by 5 are those congruent to 1, 2, 3, or 4 modulo 5. Therefore we define:
1,2,3,4âˆˆS
If xâˆˆS, then x+5âˆˆS

Problem 33
Let D={0,1,2,3,4,5,6,7,8,9} be the set of decimal digits.

We define a function m that finds the smallest digit in a string.

a) Base case: For a string of length 1, i.e.,
xâˆˆD, then m(x)=x
Recursive case: Let the string be
s=tx, where tâˆˆD* and xâˆˆD. Then: m(s)=min(m(s'),x), where s' is the prefix of s and x is the new digit appended

b) Let s=wx, where wâˆˆD* and xâˆˆD. If w=Î» (empty string), then:
m(s)=m(x)=x
Otherwise, let s=tx (t is a string, x a digit). Then: m(s)=min(m(t),x)
Suppose, s=uv, then using structural induction: m(st)=min(min(m(s),m(t)),x)=min(m(s),min(m(t),x))=min(m(s),m(t))
This shows that the minimum digit of the full string equals the minimum digit of its parts.

Problem 39
Define the set A={0^n1^n âˆ£ nâ‰¥0}
The recursive part: To go from string sâˆˆA, add a 0 to the front and a 1 to the end. Start with empty string Î»
Generate: Î»,01,0011,000111, ...

Problem 43
Prove: For full binary trees ð‘‡, the number of nodes
n(T)â‰¥2h(T)+1
Base case: A tree with a single root. Then n(T)=1, h(T)=0, and 1â‰¥2 * 0+1
Inductive hypothesis: Assume for trees ð‘‡1 and T2
n(T1) >= 2h(T1)+1 and n(T2)>=2h(T2)+1
Recursive case:
n(T) = 1 +n(T1)+n(T2)
h(T) = 1+max(h(T1),h(T2))

Sub and simplify: n(T)â‰¥1+(2h(T1)+1)+(2h(T2)+1) = 2h(T1)+2h(T2)+3
Since, h(T) = 1+max(h(T1),h(T2)), this inequality proves n(T)>=2h(T)+1

Problem 61 â€” Log* Function
log(0)n=n
log^(k+1)n = log(log^k * n)
log*n = number of times you can apply log until result â‰¤ 1.

a)log*2=1
b)log*4=2
b)log*8=3
b)log*16=3
b)log*256=4
b)log*65536=4
b)log*2048=5